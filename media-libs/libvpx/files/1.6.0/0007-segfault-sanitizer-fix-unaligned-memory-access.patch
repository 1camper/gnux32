From b99b26cde57f682730033770ee4c57bd3bb377d3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Matthias=20R=C3=A4ncker?= <theonetruecamper@gmx.de>
Date: Sun, 9 Sep 2018 22:50:49 +0200
Subject: [PATCH 07/16] segfault/sanitizer: fix unaligned memory access
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Matthias RÃ¤ncker <theonetruecamper@gmx.de>
Change-Id: I2b9b886ca22663e8bc7f1ca114158bfacdec125a
---
 vpx_dsp/psnrhvs.c             |  9 ++++++---
 vpx_dsp/x86/avg_intrin_sse2.c |  8 ++++++++
 vpx_dsp/x86/loopfilter_sse2.c | 17 +++++++++--------
 vpx_dsp/x86/variance_sse2.c   |  8 +++++---
 vpx_ports/align.h             | 36 ++++++++++++++++++++++++++++++++++++
 5 files changed, 64 insertions(+), 14 deletions(-)
 create mode 100644 vpx_ports/align.h

diff --git a/vpx_dsp/psnrhvs.c b/vpx_dsp/psnrhvs.c
index 0ffa1b251..9360060f8 100644
--- a/vpx_dsp/psnrhvs.c
+++ b/vpx_dsp/psnrhvs.c
@@ -17,6 +17,7 @@
 #include "./vpx_config.h"
 #include "./vpx_dsp_rtcd.h"
 #include "vpx_dsp/ssim.h"
+#include "vpx_ports/align.h"
 #include "vpx_ports/system_state.h"
 
 #if !defined(M_PI)
@@ -94,9 +95,11 @@ static double calc_psnrhvs(const unsigned char *_src, int _systride,
                            double _par, int _w, int _h, int _step,
                            const float _csf[8][8]) {
   float ret;
-  int16_t dct_s[8 * 8], dct_d[8 * 8];
-  tran_low_t dct_s_coef[8 * 8], dct_d_coef[8 * 8];
-  float mask[8][8];
+  VPX_ALIGNED int16_t dct_s[8 * 8];
+  VPX_ALIGNED int16_t dct_d[8 * 8];
+  VPX_ALIGNED tran_low_t dct_s_coef[8 * 8];
+  VPX_ALIGNED tran_low_t dct_d_coef[8 * 8];
+  double mask[8][8];
   int pixels;
   int x;
   int y;
diff --git a/vpx_dsp/x86/avg_intrin_sse2.c b/vpx_dsp/x86/avg_intrin_sse2.c
index f9af6cf97..a54b08230 100644
--- a/vpx_dsp/x86/avg_intrin_sse2.c
+++ b/vpx_dsp/x86/avg_intrin_sse2.c
@@ -9,10 +9,18 @@
  */
 
 #include <emmintrin.h>
+#include <string.h>
 
 #include "./vpx_dsp_rtcd.h"
 #include "vpx_ports/mem.h"
 
+static inline __m128i _mm_loadu_epi64(const __m128i *p) {
+  __m64 v;
+  memcpy(&v, p, sizeof(v));
+  return _mm_set_epi64((__m64)0LL, v);
+}
+#define _mm_loadl_epi64 _mm_loadu_epi64
+
 void vpx_minmax_8x8_sse2(const uint8_t *s, int p, const uint8_t *d, int dp,
                          int *min, int *max) {
   __m128i u0, s0, d0, diff, maxabsdiff, minabsdiff, negdiff, absdiff0, absdiff;
diff --git a/vpx_dsp/x86/loopfilter_sse2.c b/vpx_dsp/x86/loopfilter_sse2.c
index 739adf31d..e9053d2fd 100644
--- a/vpx_dsp/x86/loopfilter_sse2.c
+++ b/vpx_dsp/x86/loopfilter_sse2.c
@@ -11,6 +11,7 @@
 #include <emmintrin.h>  // SSE2
 
 #include "./vpx_dsp_rtcd.h"
+#include "vpx_ports/align.h"
 #include "vpx_ports/mem.h"
 #include "vpx_ports/emmintrin_compat.h"
 
@@ -207,21 +208,21 @@ void vpx_lpf_vertical_4_sse2(uint8_t *s, int p /* pitch */,
   // 00 10 20 30 01 11 21 31  02 12 22 32 03 13 23 33
   ps1ps0 = _mm_unpacklo_epi8(ps1ps0, x0);
 
-  *(int *)(s + 0 * p - 2) = _mm_cvtsi128_si32(ps1ps0);
+  vpx_store_unaligned_uint32(s + 0 * p - 2, _mm_cvtsi128_si32(ps1ps0));
   ps1ps0 = _mm_srli_si128(ps1ps0, 4);
-  *(int *)(s + 1 * p - 2) = _mm_cvtsi128_si32(ps1ps0);
+  vpx_store_unaligned_uint32(s + 1 * p - 2, _mm_cvtsi128_si32(ps1ps0));
   ps1ps0 = _mm_srli_si128(ps1ps0, 4);
-  *(int *)(s + 2 * p - 2) = _mm_cvtsi128_si32(ps1ps0);
+  vpx_store_unaligned_uint32(s + 2 * p - 2, _mm_cvtsi128_si32(ps1ps0));
   ps1ps0 = _mm_srli_si128(ps1ps0, 4);
-  *(int *)(s + 3 * p - 2) = _mm_cvtsi128_si32(ps1ps0);
+  vpx_store_unaligned_uint32(s + 3 * p - 2, _mm_cvtsi128_si32(ps1ps0));
 
-  *(int *)(s + 4 * p - 2) = _mm_cvtsi128_si32(qs1qs0);
+  vpx_store_unaligned_uint32(s + 4 * p - 2, _mm_cvtsi128_si32(qs1qs0));
   qs1qs0 = _mm_srli_si128(qs1qs0, 4);
-  *(int *)(s + 5 * p - 2) = _mm_cvtsi128_si32(qs1qs0);
+  vpx_store_unaligned_uint32(s + 5 * p - 2, _mm_cvtsi128_si32(qs1qs0));
   qs1qs0 = _mm_srli_si128(qs1qs0, 4);
-  *(int *)(s + 6 * p - 2) = _mm_cvtsi128_si32(qs1qs0);
+  vpx_store_unaligned_uint32(s + 6 * p - 2, _mm_cvtsi128_si32(qs1qs0));
   qs1qs0 = _mm_srli_si128(qs1qs0, 4);
-  *(int *)(s + 7 * p - 2) = _mm_cvtsi128_si32(qs1qs0);
+  vpx_store_unaligned_uint32(s + 7 * p - 2, _mm_cvtsi128_si32(qs1qs0));
 }
 
 void vpx_lpf_horizontal_edge_8_sse2(unsigned char *s, int p,
diff --git a/vpx_dsp/x86/variance_sse2.c b/vpx_dsp/x86/variance_sse2.c
index 6987c2e24..7d37733f6 100644
--- a/vpx_dsp/x86/variance_sse2.c
+++ b/vpx_dsp/x86/variance_sse2.c
@@ -13,6 +13,7 @@
 #include "./vpx_config.h"
 #include "./vpx_dsp_rtcd.h"
 
+#include "vpx_ports/align.h"
 #include "vpx_ports/mem.h"
 
 typedef void (*getNxMvar_fn_t) (const unsigned char *src, int src_stride,
@@ -34,9 +35,10 @@ unsigned int vpx_get_mb_ss_sse2(const int16_t *src) {
   return  _mm_cvtsi128_si32(vsum);
 }
 
-#define READ64(p, stride, i) \
-  _mm_unpacklo_epi8(_mm_cvtsi32_si128(*(const uint32_t *)(p + i * stride)), \
-      _mm_cvtsi32_si128(*(const uint32_t *)(p + (i + 1) * stride)))
+#define READ64(p, stride, i)                                  \
+  _mm_unpacklo_epi8(                                          \
+      _mm_cvtsi32_si128(vpx_load_unaligned_uint32(p + i * stride)), \
+      _mm_cvtsi32_si128(vpx_load_unaligned_uint32(p + (i + 1) * stride)))
 
 static void get4x4var_sse2(const uint8_t *src, int src_stride,
                            const uint8_t *ref, int ref_stride,
diff --git a/vpx_ports/align.h b/vpx_ports/align.h
new file mode 100644
index 000000000..ca3b7eacf
--- /dev/null
+++ b/vpx_ports/align.h
@@ -0,0 +1,36 @@
+#ifndef VPX_PORTS_ALIGN_H_
+#define VPX_PORTS_ALIGN_H_
+
+#include <string.h>
+#include "./vpx_config.h"
+#include "vpx/vpx_integer.h"
+
+#ifdef _MSC_VER
+#define VPX_ALIGNAS(x) __declspec(align(x))
+#elif defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_C)
+#define VPX_ALIGNAS(x) __attribute__((aligned(x)))
+#else
+#define VPX_ALIGNAS(x)
+#endif
+
+#if HAVE_AVX512
+#define VPX_ALIGNED VPX_ALIGNAS(64)
+#elif HAVE_AVX
+#define VPX_ALIGNED VPX_ALIGNAS(32)
+#elif HAVE_SSE
+#define VPX_ALIGNED VPX_ALIGNAS(16)
+#else
+#define VPX_ALIGNED VPX_ALIGNAS(8)
+#endif
+
+static inline void vpx_store_unaligned_uint32(void* dst, uint32_t v) {
+    memcpy(dst, &v, sizeof(v));
+}
+
+static inline uint32_t vpx_load_unaligned_uint32(const void* src) {
+    uint32_t v;
+    memcpy(&v, src, sizeof(v));
+    return v;
+}
+
+#endif  // VPX_PORTS_ALIGN_H_
-- 
2.16.4

