commit 77e95425e62db9f45e619576aabe03ea4bfd2e72
Author: Craig Topper <craig.topper@intel.com>
Date:   Tue Sep 11 17:57:23 2018 +0000

    [X86] Teach X86FastISel::X86SelectRet to use EAX for the sret pointer in GNUX32
    
    GNUX32 uses 32-bit pointers despite is64BitMode being true. So we should use EAX to return the value.
    
    Fixes ones of the failures from PR38865.
    
    Differential Revision: https://reviews.llvm.org/D51940
    
    cherry-picked from a8ffcb61645dc2bf13a4f530e966a384832e6802

diff --git a/llvm/lib/Target/X86/X86FastISel.cpp b/llvm/lib/Target/X86/X86FastISel.cpp
index dca6c592614..1e3d5e05cfe 100644
--- a/llvm/lib/Target/X86/X86FastISel.cpp
+++ b/llvm/lib/Target/X86/X86FastISel.cpp
@@ -1272,7 +1272,7 @@ bool X86FastISel::X86SelectRet(const Instruction *I) {
     unsigned Reg = X86MFInfo->getSRetReturnReg();
     assert(Reg &&
            "SRetReturnReg should have been set in LowerFormalArguments()!");
-    unsigned RetReg = Subtarget->is64Bit() ? X86::RAX : X86::EAX;
+    unsigned RetReg = Subtarget->isTarget64BitLP64() ? X86::RAX : X86::EAX;
     BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
             TII.get(TargetOpcode::COPY), RetReg).addReg(Reg);
     RetRegs.push_back(RetReg);
diff --git a/llvm/test/CodeGen/X86/pr38865-2.ll b/llvm/test/CodeGen/X86/pr38865-2.ll
new file mode 100644
index 00000000000..ab2e3e34e5f
--- /dev/null
+++ b/llvm/test/CodeGen/X86/pr38865-2.ll
@@ -0,0 +1,23 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc < %s -O0 -mtriple=x86_64-unknown-linux-gnux32 | FileCheck %s
+
+target datalayout = "e-m:e-p:32:32-i64:64-f80:128-n8:16:32:64-S128"
+
+%struct.a = type { i8 }
+
+define void @_Z1bv(%struct.a* noalias sret %agg.result) {
+; CHECK-LABEL: _Z1bv:
+; CHECK:       # %bb.0: # %entry
+; CHECK-NEXT:    pushq %rax
+; CHECK-NEXT:    .cfi_def_cfa_offset 16
+; CHECK-NEXT:    movl %edi, %eax
+; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
+; CHECK-NEXT:    callq _Z1bv
+; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
+; CHECK-NEXT:    popq %rcx
+; CHECK-NEXT:    .cfi_def_cfa_offset 8
+; CHECK-NEXT:    retq
+entry:
+  call void @_Z1bv(%struct.a* sret %agg.result)
+  ret void
+}
